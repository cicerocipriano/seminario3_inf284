\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{listings}


     
\sloppy

\title{Aplicações do problema de Multi-way number partitioning para mercados financeiros de criptomoedas}

\author{Gabriel C. M. Fernandes\inst{1}, Cicero C. Maciel \inst{1}}


\address{ Departamento de Informatica -- Universidade Federal de Viçosa
  (UFV)\\
  Caixa Postal 36570-900 -- Viçosa, MG -- Brasil
  \email{\{gabriel.fernandes1,cicero.maciel\}@ufv.br, @ufv.br}
}

\lstset{frame=tb,
  language=C++}
\setlength{\belowcaptionskip}{10pt}

\begin{document} 

\maketitle


     
\begin{resumo} 

Nesse artigo iremos discutir o uso das metaheurísticas Iterated Greedy e Algoritmo Genético para a resolução do problema da alocação de computadores e mercados em uma empresa financeira e analisaremos sua performance. Esse problema é uma variação mais restrita do Multi-way number partitioning problem com constraints cardinais, sendo inédito na literatura sobre este problema NP-hard.



\end{resumo}


\section{Introdução}


PLACEHOLDER CONTEXTO


\section{Revisão bibliográfica}
Analisando a literatura prévia sobre o MNP, não foram encontrados artigos ou publicações que lidam com a variação discutida neste artigo ou alguma variação similar. Contudo, existem variações de interesse a este trabalho, as chamadas diversity-aware, onde se tem como objetivo diversificar o máximo os conjuntos do Multi-way number partitioning, esse objetivo é o oposto do soft constraint, onde se deseja minimizar a diversidade de mercados em cada computador.  Assim, as técnicas usadas nos MNP  diversity-aware são re-utilizadas neste trabalho como uma referência do que deve ser evitado.

\section{Métodos}

Neste trabalho, todo o código usado foi escrito em C++ e usado na forma de um executável compilado. As metaheurísticas usadas foram a Iterated Greedy (IG) e o Algoritmo Genético (GA), essas duas trabalham em torno de uma classe solução, qual armazena um conjunto de computadores e as informações relacionadas aos valores de cada computador, que são derivados de seus mercados, quais fornecem a média de seus eventos como sua informação principal. 

\subsection{Iterated Greedy}


Na metaheurística Iterated greedy, a busca pela melhor solução começa pela criação de uma solução inicial, por uma função gulosa. A função gulosa ordena os mercados fornecidos pela instância por sua média de eventos em ordem decrescente, e o distribui para os computadores da solução, sendo que o computador com menor soma de seus mercados é o que recebe, isso é feito até os mercados se esgotarem ou até não ser possível achar uma solução que respeite o hard constraint, caso qual faz o programa emitir um erro e parar. Se todos os computadores tiverem sido criados corretamente, a solução inicial recebe eles, tem suas métricas calculadas e é retornada.





\begin{lstlisting}

inline void initial_greedy(instance &inst, solution &sol) {
 

 solution sol =   solution()
  markerts.sort() //Sort em ordem decrescente


  comps = computers()

  for (m in markets)
  {
         auto cm = computador_menor()
         cm.inserir(m)
         
        if(cm.valido == false)
       {
             throw error
       }
  }

  sol.computers = comps;
  sol.calculate_vals()

 return sols

};

\end{lstlisting}
\begingroup
\captionof{lstlisting}{Código da função da solução inicial greedy, Em pseudocodígo.}
\endgroup


Após a criação da solução inicial, inicia-se o processo de busca local do Iterated Greedy, nessa etapa são geradas variações da melhor solução, e se alguma delas for melhor que a melhor solução conhecida, ela substitui essa, terminando a busca. Para gerar variações de uma solução são utilizados dois tipos de mudanças, move e swap; No move, um mercado é retirado do computador e adicionado a outro. No swap, os mercados são trocados entre os computadores de maneira cíclica, ou seja,sem mudar o número de mercados em cada computador. 

Após cada mudança, usa-se de uma avaliação parcial para determinar os valores da solução, o uso da avaliação parcial reduz o tempo de execução necessário para processar cada nova solução gerada, possibilitando que a busca local seja mais eficiente do que se necessita-se de uma avaliação completa. Todos os processos acima são repetidos por um número definido de iterações, e depois da conclusão destas, a solução ótima é encontrada.



\begin{lstlisting}

inline void local_search(solution &sol) {


//Função de busca local
 

};

\end{lstlisting}
\begingroup
\captionof{lstlisting}{Código da função da busca local, Em pseudocodígo.}
\endgroup




\subsection{Algoritmo Genético}


No Algoritmo genético, a procura pela solução ótima começa pela geração da população inicial do GA, a qual tem um tamanho total definido,e é constituída metade por soluções aleatoriamente geradas e metade por soluções geradas usando a função greedy para criação da solução inicial, todas soluções são armazenadas em um min heap, e são validadas em relação ao hard constraint.



Após a geração da população inicial, começa-se o processo de reprodução e seleção das soluções. Da população total, são selecionados as soluções com os 25\% melhores valores, essas soluções selecionadas são agrupadas em pares e para cada par são gerados 4 soluções filhas, construídas de uma das metades do conjunto de computadores de cada pai, algumas destas soluções sofrem mutações, mudando aleatoriamente parte de seus computadores. Além disso, as 3\% melhores soluções das soluções escolhidas para se reproduzir são clonadas e inseridas na nova geração, isso é feito para reduzir a probabilidade das novas gerações produzirem resultados piores que as prévias, melhorando assim a performance desta metaheurística. Após cada geração, a melhor solução encontrada é armazenada no min heap,e, após todas as gerações serem criadas, a melhor solução é encontrada no topo deste heap.









\section{Experimentos}

PLACEHOLDER CRIAÇÃO DAS INSTÂNCIAS 

Após a preparação das instâncias, elas são fornecidas ao executável como um argumento da linha de comando, junto ao número de computadores a serem usados no experimento, com esses parâmetros, as metaheurísticas são capazes de procurar a melhor solução, o'que é feito por um número pré-determinado de iterações definido pela metaheurística usada, após a conclusão destas iterações,  a melhor solução encontrado é retornada.



\section{Resultados}


\section{Conclusão}


\section{Atribuição}


\end{document}
